
#import <Foundation/Foundation.h>

NSString *StringFromMyDebtSockData(Byte *data);        


//: gif
Byte user_outstandingKey[] = {23, 3, 31, 9, 241, 248, 15, 102, 54, 72, 74, 71, 32};

//: id
Byte k_modelTitle[] = {98, 2, 91, 6, 204, 21, 14, 9, 84};

//: data
Byte appBoostMessage[] = {33, 4, 64, 7, 139, 92, 77, 36, 33, 52, 33, 219};

//: title
Byte appAbaseDictionFormat[] = {24, 5, 23, 4, 93, 82, 93, 85, 78, 235};

//: file
Byte noti_naturallyTitle[] = {46, 4, 83, 4, 19, 22, 25, 18, 209};

//: pressed
Byte mIsolatedComplyName[] = {45, 7, 47, 13, 114, 101, 76, 73, 41, 227, 176, 176, 5, 65, 67, 54, 68, 68, 54, 53, 42};

//: normal
Byte app_inspireText[] = {70, 6, 89, 6, 173, 241, 21, 22, 25, 20, 8, 19, 221};

//: unicode
Byte user_partData[] = {18, 7, 60, 11, 134, 110, 180, 63, 39, 152, 173, 57, 50, 45, 39, 51, 40, 41, 176};

//: tag
Byte app_tunnelPath[] = {78, 3, 14, 5, 97, 102, 83, 89, 29};

//: info
Byte show_infoMessage[] = {48, 4, 14, 10, 150, 129, 25, 93, 93, 214, 91, 96, 88, 97, 93};

// __DEBUG__
// __CLOSE_PRINT__
//
//  NTESEmoticonManager.h
//  NIM
//
//  Created by amao on 7/2/14.
//  Copyright (c) 2014 Netease. All rights reserved.
//

// __M_A_C_R_O__
//: #import "ZZZInputEmoticonManager.h"
#import "FailManager.h"
//: #import "ZZZInputEmoticonDefine.h"

//: #import "NSString+AppleProjectKit.h"
#import "NSString+ModestGal.h"
//: #import "AppleProjectKit.h"
#import "ModestGal.h"
//: #import "UIImage+AppleProjectKit.h"
#import "UIImage+ModestGal.h"
//: #import "NSBundle+AppleProjectKit.h"
#import "NSBundle+ModestGal.h"

//: @implementation NIMInputEmoticon
@implementation InputPresentProperFoundation

- (NSString *)alongFill:(NSString *)loadColumn {
    //: OC_CUSTOM_PROPERTY_INJECT
    _loadColumn = loadColumn;
    return loadColumn;
}

//: - (EnumEmoticonType)type {
- (EnumEmoticonType)see {
    //: if (_unicode.length) {
    if ([self alongFill:_column].length) {
        //: return EnumEmoticonTypeUnicode;
        return EnumEmoticonTypeUnicode;
    }
    //: else if (_gif.length) {
    else if (_maximum.length) {
        //: return EnumEmoticonTypeGif;
        return EnumEmoticonTypeGif;
    }
    //: else {
    else {
        //: return EnumEmoticonTypeFile;
        return EnumEmoticonTypeFile;
    }
}

//: @end

- (void)setLoadColumn:(NSString *)loadColumn {
    //: OC_CUSTOM_PROPERTY_INJECT
    _loadColumn = loadColumn;
}


@end

//: @implementation NIMInputEmoticonCatalog
@implementation GenerationWeaken
//: @end

- (void)setPop:(NSArray *)pop {
    //: OC_CUSTOM_PROPERTY_INJECT
    _pop = pop;
}

- (void)setBorder:(InvestigatorLayout *)border {
    //: OC_CUSTOM_PROPERTY_INJECT
    _border = border;
}


- (InvestigatorLayout *)opinion:(InvestigatorLayout *)border {
    //: OC_CUSTOM_PROPERTY_INJECT
    _border = border;
    return border;
}

- (void)setRicePaddy:(NSDictionary *)ricePaddy {
    //: OC_CUSTOM_PROPERTY_INJECT
    _ricePaddy = ricePaddy;
}


- (NSArray *)forth:(NSArray *)pop {
    //: OC_CUSTOM_PROPERTY_INJECT
    _pop = pop;
    return pop;
}

- (NSDictionary *)nose:(NSDictionary *)ricePaddy {
    //: OC_CUSTOM_PROPERTY_INJECT
    _ricePaddy = ricePaddy;
    return ricePaddy;
}


@end

//: @implementation NIMInputEmoticonLayout
@implementation InvestigatorLayout

- (NSInteger)always:(NSInteger)messageAdmin {
    //: OC_CUSTOM_PROPERTY_INJECT
    _messageAdmin = messageAdmin;
    return messageAdmin;
}

//: @end

- (void)setMessageAdmin:(NSInteger)messageAdmin {
    //: OC_CUSTOM_PROPERTY_INJECT
    _messageAdmin = messageAdmin;
}

//: - (id)initEmojiLayout:(CGFloat)width
- (id)initA:(CGFloat)width
{
    //: self = [super init];
    self = [super init];
    //: if (self)
    if (self)
    {
        //: _rows = 3;
        _viewerGray = 3;
        //: _columes = ((width - 15 - 15) / 46.0);
        _groundCount = ((width - 15 - 15) / 46.0);
        //: _itemCountInPage = _rows * _columes -1;
        _operation = _viewerGray * [self always:_groundCount] -1;
        //: _cellWidth = (width - 15 - 15) / _columes;
        _family = (width - 15 - 15) / _groundCount;
        //: _cellHeight = 46.0;
        _resolveFloat = 46.0;
        //: _imageWidth = 46.0;
        _additionalFloat = 46.0;
        //: _imageHeight = 46.0;
        _ratioSkip = 46.0;
        //: _emoji = YES;
        _signEmoji = YES;
    }
    //: return self;
    return self;
}

//: - (id)initCharletLayout:(CGFloat)width{
- (id)initFrontBurner:(CGFloat)width{
    //: self = [super init];
    self = [super init];
    //: if (self)
    if (self)
    {
        //: _rows = 2;
        _viewerGray = 2;
        //: _columes = ((width - 15 - 15) / 70.f);
        _groundCount = ((width - 15 - 15) / 70.f);
        //: _itemCountInPage = _rows * _columes;
        _operation = _viewerGray * [self always:_groundCount];
        //: _cellWidth = (width - 15 - 15) / _columes;
        _family = (width - 15 - 15) / _groundCount;
        //: _cellHeight = 76.0;
        _resolveFloat = 76.0;
        //: _imageWidth = 70.f;
        _additionalFloat = 70.f;
        //: _imageHeight = 70.f;
        _ratioSkip = 70.f;
        //: _emoji = NO;
        _signEmoji = NO;
    }
    //: return self;
    return self;
}


@end

//: @interface ZZZInputEmoticonManager ()
@interface FailManager ()
//: @property (nonatomic,strong) NSArray *catalogs;
@property (nonatomic,strong) NSArray *choose;
//: @end
@end

//: @implementation ZZZInputEmoticonManager
@implementation FailManager

//: - (NIMInputEmoticon *)emoticonByTag:(NSString *)tag
- (InputPresentProperFoundation *)allMust:(NSString *)tag
{
    //: NIMInputEmoticon *emoticon = nil;
    InputPresentProperFoundation *emoticon = nil;
    //: if ([tag length])
    if ([tag length])
    {
        //: for (NIMInputEmoticonCatalog *catalog in _catalogs)
        for (GenerationWeaken *catalog in _choose)
        {
            //: emoticon = [catalog.tag2Emoticons objectForKey:tag];
            emoticon = [catalog.remain objectForKey:tag];
            //: if (emoticon)
            if (emoticon)
            {
                //: break;
                break;
            }
        }
    }
    //: return emoticon;
    return emoticon;
}

//: - (NIMInputEmoticonCatalog *)emoticonCatalog:(NSString *)catalogID
- (GenerationWeaken *)viewPrimary:(NSString *)catalogID
{
    //: for (NIMInputEmoticonCatalog *catalog in _catalogs)
    for (GenerationWeaken *catalog in _choose)
    {
        //: if ([catalog.catalogID isEqualToString:catalogID])
        if ([catalog.minimum isEqualToString:catalogID])
        {
            //: return catalog;
            return catalog;
        }
    }
    //: return nil;
    return nil;
}

//: + (instancetype)sharedManager
+ (instancetype)calendarManager
{
    //: static ZZZInputEmoticonManager *instance = nil;
    static FailManager *instance = nil;
    //: static dispatch_once_t onceToken;
    static dispatch_once_t onceToken;
    //: _dispatch_once(&onceToken, ^{
    _dispatch_once(&onceToken, ^{
        //: instance = [[ZZZInputEmoticonManager alloc]init];
        instance = [[FailManager alloc]init];
    //: });
    });
    //: return instance;
    return instance;
};

//: - (NIMInputEmoticon *)emoticonByID:(NSString *)emoticonID
- (InputPresentProperFoundation *)afterIgnore:(NSString *)emoticonID
{
    //: NIMInputEmoticon *emoticon = nil;
    InputPresentProperFoundation *emoticon = nil;
    //: if ([emoticonID length])
    if ([emoticonID length])
    {
        //: for (NIMInputEmoticonCatalog *catalog in _catalogs)
        for (GenerationWeaken *catalog in _choose)
        {
            //: emoticon = [catalog.id2Emoticons objectForKey:emoticonID];
            emoticon = [catalog.hisDictionary objectForKey:emoticonID];
            //: if (emoticon)
            if (emoticon)
            {
                //: break;
                break;
            }
        }
    }
    //: return emoticon;
    return emoticon;
}


//: - (void)parsePlist
- (void)refresh
{
    //: NSMutableArray *catalogs = [NSMutableArray array];
    NSMutableArray *catalogs = [NSMutableArray array];
    //: NSString *filepath = [NSBundle nim_EmojiPlistFile];
    NSString *filepath = [NSBundle theoryFile];
    //: if (filepath) {
    if (filepath) {
        //: NSArray *array = [NSArray arrayWithContentsOfFile:filepath];
        NSArray *array = [NSArray arrayWithContentsOfFile:filepath];
        //: for (NSDictionary *dict in array)
        for (NSDictionary *dict in array)
        {
            //: NSDictionary *info = dict[@"info"];
            NSDictionary *info = dict[StringFromMyDebtSockData(show_infoMessage)];
            //: NSArray *emoticons = dict[@"data"];
            NSArray *emoticons = dict[StringFromMyDebtSockData(appBoostMessage)];

            //: NIMInputEmoticonCatalog *catalog = [self catalogByInfo:info
            GenerationWeaken *catalog = [self about:info
                                                     //: emoticons:emoticons];
                                                     appealNews:emoticons];
            //: [catalogs addObject:catalog];
            [catalogs addObject:catalog];
        }
    }

    //: NSString *filegifpath = [NSBundle nim_EmojiGifPlistFile];
    NSString *filegifpath = [NSBundle unique];
    //: if (filegifpath) {
    if (filegifpath) {
        //: NSArray *array = [NSArray arrayWithContentsOfFile:filegifpath];
        NSArray *array = [NSArray arrayWithContentsOfFile:filegifpath];
        //: for (NSDictionary *dict in array)
        for (NSDictionary *dict in array)
        {
            //: NSDictionary *info = dict[@"info"];
            NSDictionary *info = dict[StringFromMyDebtSockData(show_infoMessage)];
            //: NSArray *emoticons = dict[@"data"];
            NSArray *emoticons = dict[StringFromMyDebtSockData(appBoostMessage)];

            //: NIMInputEmoticonCatalog *catalog = [self catalogByInfo:info
            GenerationWeaken *catalog = [self about:info
                                                     //: emoticons:emoticons];
                                                     appealNews:emoticons];
            //: [catalogs addObject:catalog];
            [catalogs addObject:catalog];
        }
    }

    //: _catalogs = catalogs;
    _choose = catalogs;
}


//: - (void)preloadEmoticonResource {
- (void)privacy {
    //: dispatch_async(dispatch_get_global_queue(0, 0), ^{
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        //: for (NIMInputEmoticonCatalog *catalog in _catalogs) {
        for (GenerationWeaken *catalog in _choose) {
            //: [catalog.emoticons enumerateObjectsUsingBlock:^(NIMInputEmoticon *obj, NSUInteger idx, BOOL * _Nonnull stop) {
            [catalog.invite enumerateObjectsUsingBlock:^(InputPresentProperFoundation *obj, NSUInteger idx, BOOL * _Nonnull stop) {
                //: if (obj.filename) {
                if (obj.vantage) {
                   //: __unused UIImage *image = [UIImage nim_emoticonInKit:obj.filename];
                   __unused UIImage *image = [UIImage reflection:obj.vantage];
                }
            //: }];
            }];
        }
    //: });
    });
}

//: - (void)start {};
- (void)overSource {}

//: - (NIMInputEmoticonCatalog *)catalogByInfo:(NSDictionary *)info
- (GenerationWeaken *)about:(NSDictionary *)info
                             //: emoticons:(NSArray *)emoticonsArray
                             appealNews:(NSArray *)emoticonsArray
{
    //: NIMInputEmoticonCatalog *catalog = [[NIMInputEmoticonCatalog alloc]init];
    GenerationWeaken *catalog = [[GenerationWeaken alloc]init];
    //: catalog.catalogID = info[@"id"];
    catalog.minimum = info[StringFromMyDebtSockData(k_modelTitle)];
    //: catalog.title = info[@"title"];
    catalog.link = info[StringFromMyDebtSockData(appAbaseDictionFormat)];
    //: catalog.icon = info[@"normal"];
    catalog.fieldCrop = info[StringFromMyDebtSockData(app_inspireText)];
    //: catalog.iconPressed = info[@"pressed"];
    catalog.entryPressed = info[StringFromMyDebtSockData(mIsolatedComplyName)];
    //: NSMutableDictionary *tag2Emoticons = [NSMutableDictionary dictionary];
    NSMutableDictionary *tag2Emoticons = [NSMutableDictionary dictionary];
    //: NSMutableDictionary *id2Emoticons = [NSMutableDictionary dictionary];
    NSMutableDictionary *id2Emoticons = [NSMutableDictionary dictionary];
    //: NSMutableArray *emoticons = [NSMutableArray array];
    NSMutableArray *emoticons = [NSMutableArray array];

    //: for (NSDictionary *emoticonDict in emoticonsArray) {
    for (NSDictionary *emoticonDict in emoticonsArray) {
        //: NIMInputEmoticon *emoticon = [[NIMInputEmoticon alloc] init];
        InputPresentProperFoundation *emoticon = [[InputPresentProperFoundation alloc] init];
        //: emoticon.emoticonID = emoticonDict[@"id"];
        emoticon.compartment = emoticonDict[StringFromMyDebtSockData(k_modelTitle)];
        //: emoticon.tag = emoticonDict[@"tag"];
        emoticon.beTotalled = emoticonDict[StringFromMyDebtSockData(app_tunnelPath)];
        //: emoticon.unicode = emoticonDict[@"unicode"];
        emoticon.column = emoticonDict[StringFromMyDebtSockData(user_partData)];
        //: emoticon.filename = emoticonDict[@"file"];
        emoticon.vantage = emoticonDict[StringFromMyDebtSockData(noti_naturallyTitle)];
        //: emoticon.gif = emoticonDict[@"gif"];
        emoticon.maximum = emoticonDict[StringFromMyDebtSockData(user_outstandingKey)];

        //: if (emoticon.emoticonID) {
        if (emoticon.compartment) {
            //: [emoticons addObject:emoticon];
            [emoticons addObject:emoticon];
            //: id2Emoticons[emoticon.emoticonID] = emoticon;
            id2Emoticons[emoticon.compartment] = emoticon;
        }
        //: if (emoticon.tag) {
        if (emoticon.beTotalled) {
            //: tag2Emoticons[emoticon.tag] = emoticon;
            tag2Emoticons[emoticon.beTotalled] = emoticon;
        }
    }

    //: catalog.emoticons = emoticons;
    catalog.invite = emoticons;
    //: catalog.id2Emoticons = id2Emoticons;
    catalog.hisDictionary = id2Emoticons;
    //: catalog.tag2Emoticons = tag2Emoticons;
    catalog.remain = tag2Emoticons;
    //: return catalog;
    return catalog;
}

//: - (NIMInputEmoticon *)emoticonByCatalogID:(NSString *)catalogID
- (InputPresentProperFoundation *)pastMatch:(NSString *)catalogID
                           //: emoticonID:(NSString *)emoticonID
                           added:(NSString *)emoticonID
{
    //: NIMInputEmoticon *emoticon = nil;
    InputPresentProperFoundation *emoticon = nil;
    //: if ([emoticonID length] && [catalogID length])
    if ([emoticonID length] && [catalogID length])
    {
        //: for (NIMInputEmoticonCatalog *catalog in _catalogs)
        for (GenerationWeaken *catalog in _choose)
        {
            //: if ([catalog.catalogID isEqualToString:catalogID])
            if ([catalog.minimum isEqualToString:catalogID])
            {
                //: emoticon = [catalog.id2Emoticons objectForKey:emoticonID];
                emoticon = [catalog.hisDictionary objectForKey:emoticonID];
                //: break;
                break;
            }
        }
    }
    //: return emoticon;
    return emoticon;
}

//: - (id)init
- (id)init
{
    //: if (self = [super init])
    if (self = [super init])
    {
        //: [self parsePlist];
        [self refresh];
        //: [self preloadEmoticonResource];
        [self privacy];
    }
    //: return self;
    return self;
}

//: @end
@end

Byte * MyDebtSockDataToCache(Byte *data) {
    int transitAbase = data[0];
    int rumStrictly = data[1];
    Byte camApply = data[2];
    int preceptor = data[3];
    if (!transitAbase) return data + preceptor;
    for (int i = preceptor; i < preceptor + rumStrictly; i++) {
        int value = data[i] + camApply;
        if (value > 255) {
            value -= 256;
        }
        data[i] = value;
    }
    data[0] = 0;
    data[preceptor + rumStrictly] = 0;
    return data + preceptor;
}

NSString *StringFromMyDebtSockData(Byte *data) {
    return [NSString stringWithUTF8String:(char *)MyDebtSockDataToCache(data)];
}
